# Nono-Gram

![P25_hard](https://github.com/seunghwanji/Nono-Gram/blob/master/image/gif/P25_hard.gif)

**NonoGram**(**네모로직**)이란?    
아래의 몇가지 규칙을 만족시키는 그림을 만들어나가는 게임.    
- 쓰인 숫자 만큼의 연속된 칸을 칠해야 한다.    
- 숫자와 숫자 사이에는 적어도 한칸을 비워야 한다.    
- 숫자의 순서와 칠해진 칸의 순서는 일치해야 한다.    

Nonogram을 풀 때에는 몇가지 공식이 존재한다.    


예를들어 다음과 같은 퍼즐이 주어진다고 가정해보자.     
- 가로로 7칸의 박스에서 숫자 5가 입력된 경우.    

다음과 같은 상황에서 칠해질 수 있는 경우의 수는 3가지가 존재한다.        
또한, 3가지의 경우 모두에서 색칠이 되는 부분이 3곳 존재한다.        
이러한 부분들을 미리 칠해놓으면 다음 블록에서 많은 경우의 수를 줄여나갈 수 있다.    


마찬가지로 숫자가 여러개 입력된 경우를 생각해보자.    
- 가로로 7칸의 박스에서 숫자 1,3이 입력된 경우.    

이렇게 여러개의 숫자가 입력된 경우도 위에서와 같이 미리 계산된 부분을 찾아낼 수 있다. (오른쪽 두번째 칸)    
다음으로 네모로직의 규칙상 주어진 숫자와 색칠된 부분의 숫자가 같으면 최소 한칸이상은 비워두어야한다.    
(이 부분은 어렵지 않으므로 패스)    


사실 이 부분만으로 모든 퍼즐을 풀 수 있는건 아니다.    
다음과 같은 경우를 생각해보자.    
- 2*2 행렬에서 행에 대하여 [[1],[1]], 열에 대하여 [[1],[1]]의 입력이 들어온 경우.    
다음과 같은 경우는 위의 알고리즘 만으로는 색칠되는 부분을 찾아낼 수 없다.    
직접 경우를 대입해보고 맞춰나가는 방법밖에 없다.    
퍼즐의 정답도 두가지 존재한다.    
**OX  XO**    
**XO  OX**    

나는 이런 Nonogram을 자동화하기 위해 다음과 같은 알고리즘을 생각했다.
먼저 확실히 해결할 수 있는 부분을 찾는 try_solve 함수와 경우의 수에 따라 답을 찾아내는 try_error함수를 구현한다.
**try_solve**
1. 시작은 열을 기준으로 열의 방향과 행의 방향을 번갈아가며 시행한다.
2. 주어진 숫자에 대해 가능한 블록의 경우를 모두 더하고 더해진 숫자가 가능한 경우의수와 같은 경우를 미리 퍼즐에 미리 색칠한다.
3. 퍼즐에 숫자가 주어진 숫자와 같은 부분이 생기면 양쪽 끝부분은 색칠될 수 없으므로 X표시를 한다.
4. 다음과 같은 과정의 반복으로 이전 퍼즐의 내용과 변함이 없으면 try_solve 함수를 종료한다.
