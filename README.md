# Nono-Gram

![P25_hard](https://github.com/seunghwanji/Nono-Gram/blob/master/image/gif/P25_hard.gif)

**NonoGram**(**네모로직**)이란?    

아래의 몇가지 규칙을 만족시키는 그림을 만들어나가는 게임.    
- 쓰인 숫자 만큼의 연속된 칸을 칠해야 한다.    
- 숫자와 숫자 사이에는 적어도 한칸을 비워야 한다.    
- 숫자의 순서와 칠해진 칸의 순서는 일치해야 한다.    

Nonogram을 풀 때에는 몇가지 공식이 존재한다.


예를들어 다음과 같은 퍼즐이 주어진다고 가정해보자.     
- 가로로 7칸의 박스에서 숫자 5가 입력된 경우.    

다음과 같은 상황에서 칠해질 수 있는 경우의 수는 3가지가 존재한다.        
또한, 3가지의 경우 모두에서 색칠이 되는 부분이 3곳 존재한다.        
이러한 부분들을 미리 칠해놓으면 다음 블록에서 많은 경우의 수를 줄여나갈 수 있다.    


마찬가지로 숫자가 여러개 입력된 경우를 생각해보자.    
- 가로로 7칸의 박스에서 숫자 1,3이 입력된 경우.    

이렇게 여러개의 숫자가 입력된 경우도 위에서와 같이 미리 계산된 부분을 찾아낼 수 있다. (오른쪽 두번째 칸)    
다음으로 네모로직의 규칙상 주어진 숫자와 색칠된 부분의 숫자가 같으면 최소 한칸이상은 비워두어야한다.    
(이 부분은 패스)    


사실 이 부분만으로 모든 퍼즐을 풀 수 있는건 아니다.    
다음과 같은 경우를 생각해보자.    
- 2*2 행렬에서 행에 대하여 [[1],[1]], 열에 대하여 [[1],[1]]의 입력이 들어온 경우.    

다음과 같은 경우는 위의 알고리즘 만으로는 색칠되는 부분을 찾아낼 수 없다.    
직접 경우를 대입해보고 맞춰나가는 방법밖에 없다.    
퍼즐의 정답도 두가지 존재한다.    
**OX  XO**    
**XO  OX**    

나는 이런 Nonogram Solver를 만들기 위해 다음과 같은 알고리즘을 생각했다.

- 입력 형식     
P = [행의 수, 열의 수, [행 별 블록 값 ex.[1, 1]],[행 별 블록 값 ex.[1, 1]]]    

* 입력 예시    
P2 = [2,2,[1],[1],[1],[1]]    
P5=[5,5,[1,1],[5],[5],[3],[1],[2],[4],[4],[4],[2]]    
P10 = [10,10,[1,1,1,1],[3,3],[1,1],[1,1,1,1],[8],[6],[10],[6],[2,4,2],[1,1],[2,1,2],[4,1,1],[2,4],[6],[5],[5],[6],[2,4],[4,1,1],[2,1,2]]    
P20 = [20,20, [2,5,2], [3,5,4], [1,14], [1,2,4,1,1,3], [1,1,2,2,3,1],[3,10,2],[6,3,1,3],[7,4],[3,4,2],[2,2,3,1,3],[1,2,2,1,1,2],[1,2,4,3,1,1],[1,2,2,4,4],[2,2,3,2,3],[1,5,3,2],[5,2],[3,3,1,1],[2,1,1,1,4],[2,3,3,2,1,2],[2,2,4,1,1],[5,2],[2,2,3],[3,1,2,3],[1,4,7,2],[1,5,2,4,2],[1,1,4,2,2,1],[3,1,3,7],[1,7,2,2,1,1],[3,7,1,5],[3,1,1,1,1,2,2],[4,2,5,1,2,1],[3,5,4,2],[3,4,5,1],[1,2,1,1,1],[1,1,2,1,1,1],[5,1,2,1],[2,2,1,4,1],[3,1,1,1,1,1,1],[7,1,2,3],[4,2,2]]    
P25_hard =[25,25,[8,2,4,3],[7,1,1,2,2],[7,2,2,2,2],[5,1,2,2,1],[4,3,3,1,1],[3,4,2,1,1,1,1,1],[4,1,4,2,1,1,1],[3,5,3,2],[2,2,2,1,2,3],[4,2,1,2,1,2],[2,1,1,1,3,4,2,2],[1,1,1,4,2,4,1,1],[2,1,4,4,4,1],[1,1,4,2,2,1,3],[1,1,3,2,5,1],[1,1,4,1,1],[4,4,2],[2,2,4,1,2],[1,8,1],[2,4,1,1],[1,1,2,2,1,4],[2,2,2,3,5],[2,1,2,1,2,2],[1,2,2,4,2],[2,2,2,3,1],[5,2,4,4,1],[8,2,1,1,2,3],[8,1,1,1,2,2],[7,2,1,1,2,3],[4,2,1,1,1,3,1],[3,4,1,5,1,2],[3,2,1,1,8,3],[1,18],[7,2,4],[3,2,2,6],[1,1,1, 3,7],[3,2,3,2],[1,2,2],[2,1,2,2],[2,7,2],[5,2,2,1,1,1],[3,1,2,8],[1,2,2,1,2],[1,1,1,1,1],[2,1,4,2],[2,2,3,1,2],[2,3,1,2,2],[1,6,3,4],[3,4,1,3],[6,7,2]]    
P25 =[25,25,[1,1,1,2,2,2,1],[1,1,1,1,2],[2,3,1,3],[6,1,2],[7,1],[1,1,3,1],[5,1,1,2],[5,2,1],[5,1,2],[6,3,1],[6,2,2,1],[10,3],[5,2,3,4],[4,1,3,6],[4,1,1,2,2,1,2],[3,1,2,1,4,2,1],[1,3,2,2,1,1],[5,3,2,1,1],[8,4,1,1],[10,2,2],[12,3,1],[11,4,1],[9,6,2],[8,8,2],[7,10,3],[2,12,7],[4,10,7],[2,10,8],[5,9,8],[3,7,9],[5,3,11],[4,1,9],[1,3,5,6],[2,4,2,4,1],[1,4,2,3,1],[9,1,2,2],[1,2,1,3],[2,3,1,3],[1,2,2,4],[1,2,9],[1,1,2,6],[1,1,5],[1,2],[2],[1,2],[1,1],[4],[2,3,5,1],[3,1,4,6],[3,2,9,3]]    
P30_hard =[30,30,[8,11,1],[8,18],[1,1,10,1,1],[8,6,2,7],[1,1,5,1,6],[1,1,5,4,1],[3,3,5,4,4],[3,3,7,1,2],[3,3,6,1,3],[5,1,5],[4,3,5,2,2],[4,4,4,2,5],[4,1,3,4,2,3],[4,1,2,3,1,5],[1,2,5,2,4],[1,4,3,2,6],[1,4,2,1,1,3],[1,4,2,4,3],[2,1,1,2,9],[2,3,2,2,2,1,2,1],[2,2,1,3,2,6],[2,3,2,1,2,1,1,4,4],[2,3,2,1,2,1,2,5,1],[2,1,1,2,2,1,1,2,3],[2,1,1,2,1,1,2,5],[1,1,2,1,1,3],[4,2,1,2,2],[4,1,2,1,4],[4,1,1,1,1,1],[1,4,1,1,2],[3,4,3,6,3],[3,4,6,3],[9,4,3,3],[2,1,4,3,1,8],[2,1,3,1,2],[2,1,8,1,5],[2,1,2],[2,1,3,3,10],[2,1,3,4,10,3],[9,3],[5],[8,3,4],[14,1,2,2],[16,1,5,3],[21,1],[11,2,6,1],[5,2,3,6],[4,2,2,5],[3,2,2,2,2,1],[11,2,2,2,1,2,2],[4,2,1,1,2,2,1],[3,2,1,1,2,2,2,1],[2,1,1,2,1,1,1,1,1],[2,2,2,1,2,1,1,3,1,1],[1,2,1,1,1,1,1,5,1],[4,1,1,2,1,1,1,3,1],[1,2,1,2,1,2,1,5,2],[2,1,1,1,1,1,3,1,1],[1,1,1,1,1,1,2,1],[3,1,1,1,2,2,2]]    

먼저 확실히 해결할 수 있는 부분을 찾는 try_solve 함수와 경우의 수에 따라 답을 찾아내는 try_error 함수를 구현한다.    
**try_solve**
1. 시작은 열을 기준으로 열의 방향과 행의 방향을 번갈아가며 시행한다.
2. 주어진 숫자에 대해 가능한 블록의 경우를 모두 더하고 더해진 숫자가 가능한 경우의수와 같은 경우를 미리 퍼즐에 미리 색칠한다.
3. 퍼즐에 숫자가 주어진 숫자와 같은 부분이 생기면 양쪽 끝부분은 색칠될 수 없으므로 X표시를 한다.
4. 다음과 같은 과정의 반복으로 이전 퍼즐의 내용과 변함이 없으면 try_solve 함수를 종료한다.

다음은 try_error 함수이다.    
(사전에 현재 진행된 board판과 각각의 열에 대해서 가능한 블록들을 key = 열 번호, value = 가능한 블록list 형태의 dictionary구조에 저장한 후, value의 길이순으로 정렬해 놓는다.)    
**try_error** // try_error 함수를 들어가기 전, value의 길이별로 dictionary를 정렬한 이유는 try_error에서 하나의 답을 최대한 빨리 return하기 위함이었지만, 답이 여러개가 존재하는 경우 모든 답을 출력하기위해 dfs를 활용한 완전탐색 알고리즘을 사용하였다.    
1. key의 길이와 같은 visited 방문 배열을 만들어 dfs형식으로 pointer를 이동시키며 하나씩 값을 대입해본다.
2. pointer가 배열의 끝부분에 도착했을 때, 현재 보드판에서 행의 값이 입력값과 같이 저장되어 있는지 확인하고 모든 행의 값이 정확히 입력되어 있으면, 현재 보트판을 print한다.
3. visited배열과 dictionary value의 length가 같으면 함수를 종료한다.    
    
* 보완할 점
1. try_solve에서 가능한 블록들을 찾아내는 함수를 필요 이상으로 실행하는 부분이 있다. 메모리를 투자해서 해당 값들을 함수 실행 전체에서 갖고있다면, 함수의 실행속도가 조금이나마 줄어들 수 있을 것 이다.
2. try_error에서 가능한 배열을 대입하는 과정마다 올바른 보드의 생성 가능성 여부를 확인하여 가능성이 없을 경우 마지막 대입한 열에 대하여 다음값을 대입해보는 backtracking 알고리즘을 사용하면 시간효율이 훤씬 상승할 수 있을 것 이다.
3. 마지막으로 numpy 모듈이나 작은 알고리즘들의 bad coding 대신, 파이썬의 기본 함수들(operator, iterator, collections 등)을 폭넓게 활용했으면, 보다 clean한 코드를 짤 수 있었을 것 임에 강한 아쉬움이 든다.
